{
  "codechef temp": {
  "prefix": "chef",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "template <typename T>",
    "using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "",
    "#define int long long",
    "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
    "constexpr int INF = 1e18, MOD = 1000000007;",
    "",
    "struct Mint {",
    "    int x;",
    "    Mint(int x = 0) : x((x% MOD + MOD) % MOD) {",
    "    }",
    "    explicit operator int() const {",
    "        return x;",
    "    }",
    "    bool operator==(const Mint& rhs) const {",
    "        return x == rhs.x;",
    "    }",
    "    bool operator!=(const Mint& rhs) const {",
    "        return !(rhs == *this);",
    "    }",
    "    friend Mint operator+(const Mint& l, const Mint& r) {",
    "        return l.x + r.x;",
    "    }",
    "    Mint& operator+=(const Mint& o) {",
    "        return *this = *this + o;",
    "    }",
    "    friend Mint operator-(const Mint& l, const Mint& r) {",
    "        return l.x - r.x;",
    "    }",
    "    Mint operator-() const {",
    "        return -x;",
    "    }",
    "    Mint& operator-=(const Mint& o) {",
    "        return *this = *this - o;",
    "    }",
    "    friend Mint operator*(const Mint& l, const Mint& r) {",
    "        return (int)l.x * r.x;",
    "    }",
    "    Mint& operator*=(const Mint& o) {",
    "        return *this = *this * o;",
    "    }",
    "    Mint pow(int b) const {",
    "        Mint ans = 1;",
    "        Mint a = *this;",
    "        while (b > 0) {",
    "            if (b & 1)",
    "                ans *= a;",
    "            a = a * a;",
    "            b >>= 1;",
    "        }",
    "        return ans;",
    "    }",
    "    friend Mint operator/(const Mint& l, const Mint& r) {",
    "        return l * r.pow(MOD - 2);",
    "    }",
    "    Mint& operator/=(const Mint& o) {",
    "        return *this = *this / o;",
    "    }",
    "    friend ostream& operator<<(ostream& os, const Mint& o) {",
    "        return os << o.x;",
    "    }",
    "};",
    "",
    "constexpr int MAX_N = 1e6 + 14;",
    "Mint fac[MAX_N] = {1}, rfac[MAX_N] = {1};",
    "",
    "void prep() {",
    "    for (int i = 1; i < MAX_N; ++i)",
    "        fac[i] = fac[i - 1] * i;",
    "    rfac[MAX_N - 1] = 1 / fac[MAX_N - 1];",
    "    for (int i = MAX_N - 2; i >= 0; --i)",
    "        rfac[i] = (i + 1) * rfac[i + 1];",
    "}",
    "",
    "Mint c(int n, int r) {",
    "    return n < r || r < 0 ? 0 : fac[n] * rfac[r] * rfac[n - r];",
    "}",
    "",
    "/* Disjoint Set */",
    "struct DSU {",
    "private:",
    "    vector<int> par, sizes;",
    "",
    "public:",
    "    DSU(int n) : par(n), sizes(n, 1) { iota(par.begin(), par.end(), 0); }",
    "    int find(int x) { return (par[x] == x ? x : par[x] = find(par[x])); }",
    "    bool unite(int x, int y) {",
    "        int x_root = find(x), y_root = find(y);",
    "        if (x_root == y_root)",
    "            return false;",
    "        if (sizes[x_root] < sizes[y_root])",
    "            swap(x_root, y_root);",
    "        sizes[x_root] += sizes[y_root];",
    "        par[y_root] = x_root;",
    "        return true;",
    "    }",
    "    int tree_len(int x) { return sizes[find(x)]; }",
    "};",
    "",
    "/* Fenwick Tree */",
    "struct FenwickTree {",
    "    vector<int> bit;",
    "    FenwickTree(int size) { bit.resize(size + 2, 0); }",
    "    void update(int i, int delta) {",
    "        for (; i < (int)bit.size(); i += (i & (-i))) {",
    "            bit[i] += delta;",
    "        }",
    "    }",
    "    int get(int i) {",
    "        int sum = 0;",
    "        for (; i > 0; i -= (i & (-i))) {",
    "            sum += bit[i];",
    "        }",
    "        return sum;",
    "    }",
    "};",
    "",
    "/* Segment Tree */",
    "struct SegmentTree {",
    "    vector<int> tree;",
    "    int n;",
    "    SegmentTree(int n) {",
    "        tree.assign(2 * n, 0);",
    "        this->n = n;",
    "    }",
    "    void build() {",
    "        for (int i = n - 1; i > 0; i--) tree[i] = tree[i << 1] + tree[i << 1 | 1];",
    "    }",
    "    void modify(int p, int val) {",
    "        for (tree[p += n] = val; p > 1; p >>= 1) tree[p >> 1] = tree[p] + tree[p ^ 1];",
    "    }",
    "    int query(int l, int r) {",
    "        int res = 0;",
    "        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
    "            if (l & 1) res += tree[l++];",
    "            if (r & 1) res += tree[--r];",
    "        }",
    "        return res;",
    "    }",
    "};",
    "",
    "template <class T, class U>",
    "// source: https://github.com/sharmaharisam/Generic_all_purpose_segtree/blob/main/Segtree.cpp",
    "struct LSegTree {",
    "    vector<T> st;",
    "    vector<U> lazy;",
    "    int n;",
    "    T identity_element;",
    "    U identity_update;",
    "    /*",
    "    identity_element: element i such that combine(i,x)=x for any x",
    "    identity_update: update u such that apply(u,x)=x for any x",
    "    sum: identity_element=0;identity_update=<some number that cannot occur as an element in array after updating too>",
    "    max: identity_element=LLONG_MIN;identity_update=0;",
    "    min: identity_element=LLONG_MAX;identity_update=0;",
    "    */",
    "    LSegTree(int n, T identity_element, U identity_update) {",
    "        this->n = n;",
    "        this->identity_element = identity_element;",
    "        this->identity_update = identity_update;",
    "        st.assign(4 * n, identity_element);",
    "        lazy.assign(4 * n, identity_update);",
    "    }",
    "",
    "    T combine(T l, T r) {",
    "        // combine 2 nodes",
    "        T ans = max(l, r);",
    "        return ans;",
    "    }",
    "",
    "    void buildUtil(int v, int tl, int tr, vector<T>& a) {",
    "        if (tl == tr) {",
    "            st[v] = a[tl];",
    "            return;",
    "        }",
    "        int tm = (tl + tr) >> 1;",
    "        buildUtil(2 * v + 1, tl, tm, a);",
    "        buildUtil(2 * v + 2, tm + 1, tr, a);",
    "        st[v] = combine(st[2 * v + 1], st[2 * v + 2]);",
    "    }",
    "",
    "    T apply(T curr, U upd, int tl, int tr) {",
    "        // transform current answer curr to new answer upd for a node",
    "        T ans = max(curr, upd);",
    "        return ans;",
    "    }",
    "",
    "    U combineUpdate(U old_upd, U new_upd, int tl, int tr) {",
    "        // update lazy node with old and new values combined..",
    "        U ans = old_upd;",
    "        ans = max(ans, new_upd);",
    "        return ans;",
    "    }",
    "",
    "    void push_down(int v, int tl, int tr) {",
    "        if (lazy[v] == identity_update)",
    "            return;",
    "        st[v] = apply(st[v], lazy[v], tl, tr);",
    "        if (2 * v + 2 < 4 * n) {",
    "            int tm = (tl + tr) >> 1;",
    "            lazy[2 * v + 1] = combineUpdate(lazy[2 * v + 1], lazy[v], tl, tm);",
    "            lazy[2 * v + 2] = combineUpdate(lazy[2 * v + 2], lazy[v], tm + 1, tr);",
    "        }",
    "        lazy[v] = identity_update;",
    "    }",
    "",
    "    T queryUtil(int v, int tl, int tr, int l, int r) {",
    "        push_down(v, tl, tr);",
    "        if (l > r)",
    "            return identity_element;",
    "        if (tr < l or tl > r) {",
    "            return identity_element;",
    "        }",
    "        if (l <= tl and r >= tr) {",
    "            return st[v];",
    "        }",
    "        int tm = (tl + tr) >> 1;",
    "        return combine(queryUtil(2 * v + 1, tl, tm, l, r), queryUtil(2 * v + 2, tm + 1, tr, l, r));",
    "    }",
    "",
    "    void updateUtil(int v, int tl, int tr, int l, int r, U upd) {",
    "        push_down(v, tl, tr);",
    "        if (tr < l or tl > r)",
    "            return;",
    "        if (tl >= l and tr <= r) {",
    "            lazy[v] = combineUpdate(lazy[v], upd, tl, tr);",
    "            push_down(v, tl, tr);",
    "        } else {",
    "            int tm = (tl + tr) >> 1;",
    "            updateUtil(2 * v + 1, tl, tm, l, r, upd);",
    "            updateUtil(2 * v + 2, tm + 1, tr, l, r, upd);",
    "            st[v] = combine(st[2 * v + 1], st[2 * v + 2]);",
    "        }",
    "    }",
    "",
    "    void build(vector<T> a) {",
    "        assert((int)a.size() == n);",
    "        buildUtil(0, 0, n - 1, a);",
    "    }",
    "    T query(int l, int r) {",
    "        return queryUtil(0, 0, n - 1, l, r);",
    "    }",
    "    void update(int l, int r, U upd) {",
    "        updateUtil(0, 0, n - 1, l, r, upd);",
    "    }",
    "};",
    "",
    "/* Sparse Table */",
    "",
    "/*",
    "    find the queries in O(1)",
    "    precalculates everything in log terms O(nlogn)",
    "    and then gives the result by using the precalculated stuff",
    "*/",
    "",
    "struct SparseTable {",
    "    vector<int> a;",
    "    vector<vector<int>> sp;",
    "    int LOG, mxeN;",
    "    SparseTable(int mxeSize) {",
    "        a.resize(mxeSize, 0);",
    "        mxeN = mxeSize;",
    "        LOG = log2(mxeSize) + 1;",
    "        sp.assign(mxeN, vector<int>(LOG, 0));",
    "    }",
    "    void modify(int idx, int val) {",
    "        a[idx] = val;",
    "        sp[idx][0] = val;",
    "    }",
    "    void build() {",
    "        for (int j = 1; j < LOG; j++) {",
    "            for (int i = 0; i + (1 << j) - 1 < mxeN; i++) {",
    "                sp[i][j] = gcd(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);",
    "            }",
    "        }",
    "    }",
    "    int query(int l, int r) {",
    "        int len = r - l + 1;",
    "        int k = 31 - __builtin_clz(len);",
    "        return gcd(sp[l][k], sp[r - (1 << k) + 1][k]);",
    "    }",
    "};",
    "",
    "/* Z-Algorithm */",
    "vector<int> z_func(string s) {",
    "    int n = s.size();",
    "    vector<int> z(n);",
    "    int x = 0, y = 0;",
    "    for (int i = 0; i < n; i++) {",
    "        z[i] = max(0LL, min(z[i - x], y - i + 1));",
    "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
    "            x = i, y = i + z[i], z[i]++;",
    "        }",
    "    }",
    "    return z;",
    "}",
    "",
    "/*********************** main ************************/",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(false);",
    "    cin.tie(0);",
    "",
    "    int tt = 1;",
    "    cin >> tt;",
    "    while (tt--) {",
    "        $0",
    "    }",
    "",
    "    return 0;",
    "}"
  ],
  "description": "codechef temp"
},
"jayant": {
  "prefix": "jayant",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "template <typename T>",
    "using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "#define int long long",
    "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
    "const int INF = 1e18, MOD = 1000000007; // 998244353;",
    "",
    "void Solve() {",
    "    $0",
    "}",
    "",
    "#undef int",
    "",
    "int main() {",
    "#ifdef ZAP",
    "    freopen(\"int\", \"r\", stdin), freopen(\"out1\", \"w\", stdout), freopen(\"err\", \"w\", stderr);",
    "#endif",
    "    auto begin = std::chrono::high_resolution_clock::now();",
    "    ios_base::sync_with_stdio(false), cin.tie(nullptr);",
    "    int T = 1;",
    "    cin >> T;",
    "    for (int i = 1; i <= T; i++) {",
    "        cerr << \"Case #\" << i << \": \" << endl;",
    "        Solve();",
    "    }",
    "    auto end = std::chrono::high_resolution_clock::now();",
    "    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);",
    "    cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\";",
    "    return 0;",
    "}"
  ],
  "description": "jayant"
},
"tnayaj": {
  "prefix": "tnayaj",
  "body": [
    "/*",
    " *  author: tnayaj",
    " *  created: $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
    "*/",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define int long long ",
    "constexpr int INF = 1e18, MOD = 1e9 + 7;",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(false);",
    "    cin.tie(0);",
    "",
    "    int tt = 1;",
    "    cin >> tt; $1",
    "    while (tt--) {",
    "        $0",
    "    }",
    "",
    "    return 0;",
    "}"
  ],
  "description": "tnayaj"
},
"jk": {
  "prefix": "jk",
  "body": [
    "/*",
    " *  author: zapwiz22",
    " *  created: $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
    "*/",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define int long long",
    "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
    "const int INF = 1e18, MOD = 1000000007; // 998244353;",
    "",
    "void Solve() {",
    "    $0    ",
    "}",
    "",
    "int32_t main() {",
    "    auto begin = std::chrono::high_resolution_clock::now();",
    "    ios_base::sync_with_stdio(false), cin.tie(nullptr);",
    "    int tt = 1;",
    "    $1cin >> tt;",
    "    for (int i = 1; i <= tt; i++) {",
    "        cerr << \"Case #\" << i << \": \" << endl;",
    "        Solve();",
    "    }",
    "    auto end = std::chrono::high_resolution_clock::now();",
    "    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);",
    "    cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\";",
    "    return 0;",
    "}"
  ],
  "description": "jk"
},
"oset": {
  "prefix": "oset",
  "body": [
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "template <typename T>",
    "using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; "
  ],
  "description": "oset"
},
"modint": {
  "prefix": "modint",
  "body": [
    "struct Mint {",
    "    int x;",
    "    Mint(int x = 0) : x((x% MOD + MOD) % MOD) {}",
    "    explicit operator int() const { return x; }",
    "    bool operator==(const Mint& rhs) const { return x == rhs.x; }",
    "    bool operator!=(const Mint& rhs) const { return !(rhs == *this); }",
    "    friend Mint operator+(const Mint& l, const Mint& r) { return l.x + r.x; }",
    "    Mint& operator+=(const Mint& o) { return *this = *this + o; }",
    "    friend Mint operator-(const Mint& l, const Mint& r) { return l.x - r.x; }",
    "    Mint operator-() const { return -x; }",
    "    Mint& operator-=(const Mint& o) { return *this = *this - o; }",
    "    friend Mint operator*(const Mint& l, const Mint& r) { return (int)l.x * r.x; }",
    "    Mint& operator*=(const Mint& o) { return *this = *this * o; }",
    "    Mint pow(int b) const {",
    "        Mint ans = 1;",
    "        Mint a = *this;",
    "        while (b > 0) {",
    "            if (b & 1)",
    "                ans *= a;",
    "            a = a * a;",
    "            b >>= 1;",
    "        }",
    "        return ans;",
    "    }",
    "    friend Mint operator/(const Mint& l, const Mint& r) { return l * r.pow(MOD - 2); }",
    "    Mint& operator/=(const Mint& o) { return *this = *this / o; }",
    "    friend ostream& operator<<(ostream& os, const Mint& o) { return os << o.x; }",
    "};",
    "",
    "constexpr int MAX_N = 1e6 + 14;",
    "Mint fac[MAX_N] = {1}, rfac[MAX_N] = {1};",
    "",
    "void prep() {",
    "    for (int i = 1; i < MAX_N; ++i)",
    "        fac[i] = fac[i - 1] * i;",
    "    rfac[MAX_N - 1] = 1 / fac[MAX_N - 1];",
    "    for (int i = MAX_N - 2; i >= 0; --i)",
    "        rfac[i] = (i + 1) * rfac[i + 1];",
    "}",
    "",
    "Mint c(int n, int r) {",
    "    return n < r || r < 0 ? 0 : fac[n] * rfac[r] * rfac[n - r];",
    "}"
  ],
  "description": "modint"
},
"z-algorithm": {
  "prefix": "zalgorithm",
  "body": [
    "/* Z-Algorithm */",
    "vector<int> z_func(string s) {",
    "    int n = s.size();",
    "    vector<int> z(n);",
    "    int x = 0, y = 0;",
    "    for (int i = 0; i < n; i++) {",
    "        z[i] = max(0, min(z[i - x], y - i + 1));",
    "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
    "            x = i, y = i + z[i], z[i]++;",
    "        }",
    "    }",
    "    return z;",
    "}",
    ""
  ],
  "description": "z-algorithm"
},
"disjoint-set": {
  "prefix": "disjointset",
  "body": [
    "struct DSU {",
    "  private:",
    "    vector<int> par, sizes;",
    "",
    "  public:",
    "    DSU(int n) : par(n), sizes(n, 1) { iota(par.begin(), par.end(), 0); }",
    "    int find(int x) { return (par[x] == x ? x : par[x] = find(par[x])); }",
    "    bool unite(int x, int y) {",
    "        int x_root = find(x), y_root = find(y);",
    "        if (x_root == y_root)",
    "            return false;",
    "        if (sizes[x_root] < sizes[y_root])",
    "            swap(x_root, y_root);",
    "        sizes[x_root] += sizes[y_root];",
    "        par[y_root] = x_root;",
    "        return true;",
    "    }",
    "    int tree_len(int x) { return sizes[find(x)]; }",
    "};",
    ""
  ],
  "description": "disjoint-set"
},
"sparse table": {
  "prefix": "sparse table",
  "body": [
    "template <typename T> class SparseTable {",
    "private:",
    "    int n, log2dist;",
    "    vector<vector<T>> st;",
    "",
    "public:",
    "    SparseTable(const vector<T>& v) {",
    "        n = (int)v.size();",
    "        log2dist = 1 + (int)log2(n);",
    "        st.resize(log2dist);",
    "        st[0] = v;",
    "        for (int i = 1; i < log2dist; i++) {",
    "            st[i].resize(n - (1 << i) + 1);",
    "            for (int j = 0; j + (1 << i) <= n; j++) {",
    "                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);",
    "            }",
    "        }",
    "    }",
    "",
    "    /** @return minimum on the range [l, r] */",
    "    T query(int l, int r) {",
    "        int i = (int)log2(r - l + 1);",
    "        return min(st[i][l], st[i][r - (1 << i) + 1]);",
    "    }",
    "};"
  ],
  "description": "sparse table"
},
"fenwick tree": {
  "prefix": "fenwick",
  "body": [
    "template <typename T>",
    "struct fenwick {",
    "    int n;",
    "    vector<T> bit;",
    "",
    "    fenwick(int n) : n(n), bit(n + 1, T()) {}",
    "",
    "    // give 0-based and operations are done 1-based ",
    "    void update(int i, T delta) {",
    "        for (++i; i <= n; i += i & -i) {",
    "            bit[i] = bit[i] + delta;",
    "        }",
    "    }",
    "    T query(int i) {",
    "        T res{};",
    "        for (++i; i > 0; i -= i & -i) {",
    "            res = res + bit[i];",
    "        }",
    "        return res;",
    "    }",
    "};",
    "",
    "struct node {",
    "    int a = 0; // don't forget the default value ",
    "",
    "    // define the required operations",
    "    inline node operator+(node& x) {",
    "        return node(a - x.a);",
    "    }",
    "    inline bool operator<(node& x) {",
    "        return a < x.a;",
    "    }",
    "};"
  ],
  "description": "fenwick tree"
},
"stress": {
  "prefix": "stress",
  "body": [
    "#!/bin/bash",
    "",
    "g++ sol.cpp -o sol",
    "g++ brute.cpp -o brute",
    "g++ gen.cpp -o gen",
    "",
    "for ((i = 1; i <= 1000; ++i)); do",
    "    echo $i",
    "    ./gen $i >int",
    "    ./sol <int >out1",
    "    ./brute <int >out2",
    "    diff -w out1 out2 || break",
    "done"
  ],
  "description": "stress"
},
"generation": {
  "prefix": "gen",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "#define int long long ",
    "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)",
    "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "int32_t main() {",
    "    int tests = 1;",
    "    cout << tests << endl;",
    "",
    "    // generation ",
    "    $0",
    "",
    "    return 0;",
    "}",
    "",
    "/* how to generate a tree",
    "  print uid(1,i-1) and i",
    "*/",
    "",
    "/* how to randomly shuffle a vector",
    "   // Initialize random number generator",
    "    random_device rd;",
    "    mt19937 g(rd());",
    "",
    "    // Shuffle the vector",
    "    shuffle(v.begin(), v.end(), g);",
    "*/"
  ],
  "description": "generation"
},
"debug.h": {
  "prefix": "debug",
  "body": [
    "#ifndef DEBUG_H",
    "#define DEBUG_H",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "// Forward declarations for all _print functions",
    "void _print(int x);",
    "void _print(long x);",
    "void _print(long long x);",
    "void _print(unsigned x);",
    "void _print(unsigned long x);",
    "void _print(unsigned long long x);",
    "void _print(float x);",
    "void _print(double x);",
    "void _print(long double x);",
    "void _print(char x);",
    "void _print(const char* x);",
    "void _print(const string& x);",
    "void _print(bool x);",
    "",
    "template<typename T1, typename T2>",
    "void _print(const pair<T1, T2>& p);",
    "",
    "template<typename T>",
    "void _print(const vector<T>& v);",
    "",
    "template<typename T>",
    "void _print(const set<T>& s);",
    "",
    "template<typename T>",
    "void _print(const unordered_set<T>& s);",
    "",
    "template<typename T>",
    "void _print(const multiset<T>& s);",
    "",
    "template<typename K, typename V>",
    "void _print(const map<K, V>& m);",
    "",
    "template<typename K, typename V>",
    "void _print(const unordered_map<K, V>& m);",
    "",
    "template<typename T, size_t N>",
    "void _print(const array<T, N>& arr);",
    "",
    "template<typename T>",
    "void _print(const deque<T>& dq);",
    "",
    "template<typename T>",
    "void _print(stack<T> st);",
    "",
    "template<typename T>",
    "void _print(queue<T> q);",
    "",
    "template<typename T>",
    "void _print(priority_queue<T> pq);",
    "",
    "template<typename T>",
    "void _print(priority_queue<T, vector<T>, greater<T>> pq);",
    "",
    "template<typename T>",
    "void _print(const list<T>& lst);",
    "",
    "template<typename T>",
    "void _print(const forward_list<T>& flst);",
    "",
    "template<size_t N>",
    "void _print(const bitset<N>& bs);",
    "",
    "template<typename... Args>",
    "void _print(const tuple<Args...>& t);",
    "",
    "template<typename T>",
    "void _print(const complex<T>& c);",
    "",
    "// Core type printers implementation",
    "void _print(int x) { cerr << x; }",
    "void _print(long x) { cerr << x; }",
    "void _print(long long x) { cerr << x; }",
    "void _print(unsigned x) { cerr << x; }",
    "void _print(unsigned long x) { cerr << x; }",
    "void _print(unsigned long long x) { cerr << x; }",
    "void _print(float x) { cerr << x; }",
    "void _print(double x) { cerr << x; }",
    "void _print(long double x) { cerr << x; }",
    "void _print(char x) { cerr << '\\'' << x << '\\''; }",
    "void _print(const char* x) { cerr << '\\\"' << x << '\\\"'; }",
    "void _print(const string& x) { cerr << '\\\"' << x << '\\\"'; }",
    "void _print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
    "",
    "// Pair",
    "template<typename T1, typename T2>",
    "void _print(const pair<T1, T2>& p) {",
    "    cerr << '{';",
    "    _print(p.first);",
    "    cerr << ',';",
    "    _print(p.second);",
    "    cerr << '}';",
    "}",
    "",
    "// Vector",
    "template<typename T>",
    "void _print(const vector<T>& v) {",
    "    cerr << '[';",
    "    for (size_t i = 0; i < v.size(); i++) {",
    "        if (i > 0) cerr << ',';",
    "        _print(v[i]);",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Set",
    "template<typename T>",
    "void _print(const set<T>& s) {",
    "    cerr << '{';",
    "    for (auto it = s.begin(); it != s.end();) {",
    "        _print(*it);",
    "        if (++it != s.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Unordered Set",
    "template<typename T>",
    "void _print(const unordered_set<T>& s) {",
    "    cerr << '{';",
    "    for (auto it = s.begin(); it != s.end();) {",
    "        _print(*it);",
    "        if (++it != s.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Multiset",
    "template<typename T>",
    "void _print(const multiset<T>& s) {",
    "    cerr << '{';",
    "    for (auto it = s.begin(); it != s.end();) {",
    "        _print(*it);",
    "        if (++it != s.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Map",
    "template<typename K, typename V>",
    "void _print(const map<K, V>& m) {",
    "    cerr << '{';",
    "    for (auto it = m.begin(); it != m.end();) {",
    "        _print(it->first);",
    "        cerr << ':';",
    "        _print(it->second);",
    "        if (++it != m.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Unordered Map",
    "template<typename K, typename V>",
    "void _print(const unordered_map<K, V>& m) {",
    "    cerr << '{';",
    "    for (auto it = m.begin(); it != m.end();) {",
    "        _print(it->first);",
    "        cerr << ':';",
    "        _print(it->second);",
    "        if (++it != m.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Array",
    "template<typename T, size_t N>",
    "void _print(const array<T, N>& arr) {",
    "    cerr << '[';",
    "    for (size_t i = 0; i < N; i++) {",
    "        if (i > 0) cerr << ',';",
    "        _print(arr[i]);",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Deque",
    "template<typename T>",
    "void _print(const deque<T>& dq) {",
    "    cerr << '[';",
    "    for (size_t i = 0; i < dq.size(); i++) {",
    "        if (i > 0) cerr << ',';",
    "        _print(dq[i]);",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Stack",
    "template<typename T>",
    "void _print(stack<T> st) {",
    "    vector<T> temp;",
    "    while (!st.empty()) {",
    "        temp.push_back(st.top());",
    "        st.pop();",
    "    }",
    "    reverse(temp.begin(), temp.end());",
    "    cerr << \"stack:\";",
    "    _print(temp);",
    "}",
    "",
    "// Queue",
    "template<typename T>",
    "void _print(queue<T> q) {",
    "    vector<T> temp;",
    "    while (!q.empty()) {",
    "        temp.push_back(q.front());",
    "        q.pop();",
    "    }",
    "    cerr << \"queue:\";",
    "    _print(temp);",
    "}",
    "",
    "// Priority Queue (max heap)",
    "template<typename T>",
    "void _print(priority_queue<T> pq) {",
    "    vector<T> temp;",
    "    while (!pq.empty()) {",
    "        temp.push_back(pq.top());",
    "        pq.pop();",
    "    }",
    "    cerr << \"max_heap:\";",
    "    _print(temp);",
    "}",
    "",
    "// Priority Queue (min heap)",
    "template<typename T>",
    "void _print(priority_queue<T, vector<T>, greater<T>> pq) {",
    "    vector<T> temp;",
    "    while (!pq.empty()) {",
    "        temp.push_back(pq.top());",
    "        pq.pop();",
    "    }",
    "    cerr << \"min_heap:\";",
    "    _print(temp);",
    "}",
    "",
    "// List",
    "template<typename T>",
    "void _print(const list<T>& lst) {",
    "    cerr << '[';",
    "    for (auto it = lst.begin(); it != lst.end();) {",
    "        _print(*it);",
    "        if (++it != lst.end()) cerr << ',';",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Forward List",
    "template<typename T>",
    "void _print(const forward_list<T>& flst) {",
    "    cerr << '[';",
    "    for (auto it = flst.begin(); it != flst.end();) {",
    "        _print(*it);",
    "        if (++it != flst.end()) cerr << ',';",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Bitset",
    "template<size_t N>",
    "void _print(const bitset<N>& bs) {",
    "    cerr << \"bitset:\\\"\";",
    "    for (size_t i = 0; i < N; i++) {",
    "        cerr << (bs.test(i) ? '1' : '0');",
    "    }",
    "    cerr << \"\\\"\";",
    "}",
    "",
    "// Tuple",
    "template<typename Tuple, size_t... Is>",
    "void _print_tuple(const Tuple& t, index_sequence<Is...>) {",
    "    cerr << '(';",
    "    (..., (cerr << (Is == 0 ? \"\" : \",\"), _print(get<Is>(t))));",
    "    cerr << ')';",
    "}",
    "",
    "template<typename... Args>",
    "void _print(const tuple<Args...>& t) {",
    "    _print_tuple(t, index_sequence_for<Args...>{});",
    "}",
    "",
    "// Complex",
    "template<typename T>",
    "void _print(const complex<T>& c) {",
    "    cerr << c.real();",
    "    if (c.imag() >= 0) cerr << '+';",
    "    cerr << c.imag() << 'i';",
    "}",
    "",
    "// Main debug function",
    "#define debug(...) debug_print(#__VA_ARGS__, __VA_ARGS__)",
    "",
    "template<typename... Args>",
    "void debug_print(const char* names, Args&&... args) {",
    "    cerr << \"\\033[1;36m\";",
    "    stringstream ss(names);",
    "    string name;",
    "    vector<string> vnames;",
    "    ",
    "    // Parse variable names",
    "    while (getline(ss, name, ',')) {",
    "        name.erase(0, name.find_first_not_of(\" \\t\\n\\r\\f\\v\"));",
    "        name.erase(name.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);",
    "        vnames.push_back(name);",
    "    }",
    "    ",
    "    // Print each variable with its name",
    "    int i = 0;",
    "    ((cerr << (i++ ? \" | \" : \"\") << vnames[i-1] << \" = \", _print(args)), ...);",
    "    cerr << \"\\033[0m\" << endl;",
    "}",
    "",
    "#endif // DEBUG_H"
  ],
  "description": "debug.h"
},
"tarjan algo for bridges ": {
  "prefix": "tarjan-algo",
  "body": [
    "/* tarjan's algorithm for finding the bridges */",
    "vector<int> dp(n, 0), tin(n), low(n);",
    "vector<bool> vis(n, false);",
    "vector<pair<int, int>> bridges;",
    "int t = 0;",
    "function<void(int, int)> dfs = [&](int u, int p) {",
    "    vis[u] = true;",
    "    dp[u] = 1;",
    "    tin[u] = low[u] = ++t;",
    "    for (auto& v : adj[u]) {",
    "        if (v == p) continue;",
    "        if (vis[v]) {",
    "            low[u] = min(low[u], low[v]);",
    "        } else {",
    "            dfs(v, u);",
    "            dp[u] += dp[v];",
    "            low[u] = min(low[u], low[v]);",
    "            if (low[v] > tin[u]) {",
    "                bridges.push_back({u,v});",
    "            }",
    "        }",
    "    }",
    "};",
    "dfs(0, -1);"
  ],
  "description": "tarjan algo for bridges "
},
"trie": {
  "prefix": "trie",
  "body": [
    "struct Node {",
    "    Node* links[26];",
    "    bool eow;  // flag for marking the end of word",
    "    int endCount = 0;",
    "    int prefixCount = 0;",
    "",
    "    bool containsKey(char ch) {",
    "        return links[ch - 'a'] != NULL;",
    "    }",
    "",
    "    // insert a new node with a specific key (letter) to the Trie",
    "    void put(char ch, Node* node) {",
    "        links[ch - 'a'] = node;",
    "    }",
    "",
    "    // get the node associated to a specific key (letter)",
    "    Node* get(char ch) {",
    "        return links[ch - 'a'];",
    "    }",
    "",
    "    // mark the end of the word",
    "    void setEnd() {",
    "        eow = true;",
    "    }",
    "",
    "    // check is the key is the end of the word or not",
    "    bool isEnd() {",
    "        return eow;",
    "    }",
    "};",
    "",
    "class Trie {",
    "private:",
    "    Node* root;",
    "",
    "public:",
    "    Trie() {",
    "        root = new Node();",
    "    }",
    "",
    "    // insert word into the Trie",
    "    // time complexity : O(len) where len is length of the word",
    "    void insert(string word) {",
    "        Node* node = root;",
    "        for (int i = 0; i < word.length(); i++) {",
    "            if (!node->containsKey(word[i])) {",
    "                node->put(word[i], new Node());",
    "            }",
    "            node = node->get(word[i]);",
    "            node->prefixCount++;",
    "        }",
    "        node->setEnd();",
    "        node->endCount++;",
    "    }",
    "",
    "    // search for the word within the Trie",
    "    bool search(string word) {",
    "        Node* node = root;",
    "        for (int i = 0; i < word.length(); i++) {",
    "            if (!node->containsKey(word[i])) {",
    "                return false;",
    "            }",
    "            node = node->get(word[i]);",
    "        }",
    "        return node->isEnd();",
    "    }",
    "",
    "    // return whether any word with the given prefix",
    "    bool startsWith(string prefix) {",
    "        Node* node = root;",
    "        for (int i = 0; i < prefix.length(); i++) {",
    "            if (!node->containsKey(prefix[i])) {",
    "                return false;",
    "            }",
    "            node = node->get(prefix[i]);",
    "        }",
    "        return true;",
    "    }",
    "",
    "    // return the count of the occurrences of the string word in the Trie",
    "    int cntWord(string word) {",
    "        Node* node = root;",
    "        for (int i = 0; i < word.length(); i++) {",
    "            if (!node->containsKey(word[i])) {",
    "                return 0;",
    "            }",
    "            node = node->get(word[i]);",
    "        }",
    "        return node->endCount;",
    "    }",
    "",
    "    // return the count of words starting with the given prefix",
    "    int cntPrefix(string word) {",
    "        Node* node = root;",
    "        // int res = 0;",
    "        for (int i = 0; i < word.length(); i++) {",
    "            if (!node->containsKey(word[i])) {",
    "                return 0;",
    "                // return res;",
    "            }",
    "            node = node->get(word[i]);",
    "            // res += node->prefixCount;",
    "        }",
    "        return node->prefixCount;",
    "        // return res;",
    "    }",
    "",
    "    // erase a word in the given trie",
    "    void erase(string word) {",
    "        Node* node = root;",
    "        for (int i = 0; i < word.length(); i++) {",
    "            node = node->get(word[i]);",
    "            node->prefixCount--;",
    "        }",
    "        node->endCount--;",
    "    }",
    "};"
  ],
  "description": "trie"
},
"least common ancestor": {
  "prefix": "lca",
  "body": [
    "template <typename T> class SparseTable {",
    "private:",
    "    int n, log2dist;",
    "    vector<vector<T>> st;",
    "",
    "public:",
    "    SparseTable(const vector<T>& v) {",
    "        n = (int)v.size();",
    "        log2dist = 1 + (int)log2(n);",
    "        st.resize(log2dist);",
    "        st[0] = v;",
    "        for (int i = 1; i < log2dist; i++) {",
    "            st[i].resize(n - (1 << i) + 1);",
    "            for (int j = 0; j + (1 << i) <= n; j++) {",
    "                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);",
    "            }",
    "        }",
    "    }",
    "",
    "    /** @return minimum on the range [l, r] */",
    "    T query(int l, int r) {",
    "        int i = (int)log2(r - l + 1);",
    "        return min(st[i][l], st[i][r - (1 << i) + 1]);",
    "    }",
    "};",
    "",
    "class LCA {",
    "private:",
    "    const int n;",
    "    const vector<vector<int>>& adj;",
    "    SparseTable<pair<int, int>> rmq;",
    "    vector<int> tin, et, dep;",
    "    int timer = 0;",
    "",
    "    /** prepares tin, et, dep arrays */",
    "    void dfs(int u, int p) {",
    "        tin[u] = timer;",
    "        et[timer++] = u;",
    "        for (int v : adj[u]) {",
    "            if (v == p) { continue; }",
    "            dep[v] = dep[u] + 1;",
    "            dfs(v, u);",
    "            et[timer++] = u;",
    "        }",
    "    }",
    "",
    "public:",
    "    // make sure the adjacency list is 0 indexed",
    "    LCA(vector<vector<int>>& _adj)",
    "        : n((int)_adj.size()), adj(_adj), tin(n), et(2 * n), dep(n),",
    "        rmq(vector<pair<int, int>>(1)) {",
    "        dfs(0, -1);",
    "        vector<pair<int, int>> arr(2 * n);",
    "        for (int i = 0; i < 2 * n; i++) { arr[i] = {dep[et[i]], et[i]}; }",
    "        rmq = SparseTable<pair<int, int>>(arr);",
    "    }",
    "",
    "    /** @return LCA of nodes a and b */",
    "    int query(int a, int b) {",
    "        if (tin[a] > tin[b]) { swap(a, b); }",
    "        return rmq.query(tin[a], tin[b]).second;",
    "    }",
    "",
    "    /** @return dist between node a and b */",
    "    int dist(int a, int b) {",
    "        int c = query(a, b);",
    "        return dep[a] + dep[b] - 2 * dep[c];",
    "    }",
    "};"
  ],
  "description": "least common ancestor"
},
"segtree": {
  "prefix": "segtree",
  "body": [
    "template <class S, S(*op)(S, S), S(*e)()> struct segtree {",
    "public:",
    "    segtree() : segtree(0) {}",
    "    segtree(int32_t n) : segtree(std::vector<S>(n, e())) {}",
    "    segtree(const std::vector<S>& v) : _n(int32_t(v.size())) {",
    "        log = 64 - __builtin_clzll(_n);",
    "        size = 1 << log;",
    "        d = std::vector<S>(2 * size, e());",
    "        for (int32_t i = 0; i < _n; i++) d[size + i] = v[i];",
    "        for (int32_t i = size - 1; i >= 1; i--) {",
    "            update(i);",
    "        }",
    "    }",
    "",
    "    void set(int32_t p, S x) {",
    "        assert(0 <= p && p < _n);",
    "        p += size;",
    "        d[p] = x;",
    "        for (int32_t i = 1; i <= log; i++) update(p >> i);",
    "    }",
    "",
    "    S get(int32_t p) {",
    "        assert(0 <= p && p < _n);",
    "        return d[p + size];",
    "    }",
    "",
    "    S prod(int32_t l, int32_t r) {",
    "        assert(0 <= l && l <= r && r <= _n);",
    "        S sml = e(), smr = e();",
    "        l += size;",
    "        r += size;",
    "",
    "        while (l < r) {",
    "            if (l & 1) sml = op(sml, d[l++]);",
    "            if (r & 1) smr = op(d[--r], smr);",
    "            l >>= 1;",
    "            r >>= 1;",
    "        }",
    "        return op(sml, smr);",
    "    }",
    "",
    "    S all_prod() { return d[1]; }",
    "",
    "    template <bool (*f)(S)> int32_t max_right(int32_t l) {",
    "        return max_right(l, [](S x) { return f(x); });",
    "    }",
    "    template <class F> int32_t max_right(int32_t l, F f) {",
    "        assert(0 <= l && l <= _n);",
    "        assert(f(e()));",
    "        if (l == _n) return _n;",
    "        l += size;",
    "        S sm = e();",
    "        do {",
    "            while (l % 2 == 0) l >>= 1;",
    "            if (!f(op(sm, d[l]))) {",
    "                while (l < size) {",
    "                    l = (2 * l);",
    "                    if (f(op(sm, d[l]))) {",
    "                        sm = op(sm, d[l]);",
    "                        l++;",
    "                    }",
    "                }",
    "                return l - size;",
    "            }",
    "            sm = op(sm, d[l]);",
    "            l++;",
    "        } while ((l & -l) != l);",
    "        return _n;",
    "    }",
    "",
    "    template <bool (*f)(S)> int32_t min_left(int32_t r) {",
    "        return min_left(r, [](S x) { return f(x); });",
    "    }",
    "    template <class F> int32_t min_left(int32_t r, F f) {",
    "        assert(0 <= r && r <= _n);",
    "        assert(f(e()));",
    "        if (r == 0) return 0;",
    "        r += size;",
    "        S sm = e();",
    "        do {",
    "            r--;",
    "            while (r > 1 && (r % 2)) r >>= 1;",
    "            if (!f(op(d[r], sm))) {",
    "                while (r < size) {",
    "                    r = (2 * r + 1);",
    "                    if (f(op(d[r], sm))) {",
    "                        sm = op(d[r], sm);",
    "                        r--;",
    "                    }",
    "                }",
    "                return r + 1 - size;",
    "            }",
    "            sm = op(d[r], sm);",
    "        } while ((r & -r) != r);",
    "        return 0;",
    "    }",
    "",
    "private:",
    "    int32_t _n, size, log;",
    "    std::vector<S> d;",
    "",
    "    void update(int32_t k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
    "};"
  ],
  "description": "segtree"
},
"lazy segtree": {
  "prefix": "lazy-segtree",
  "body": [
    "template <class S,",
    "    S(*op)(S, S),",
    "    S(*e)(),",
    "    class F,",
    "    S(*mapping)(F, S),",
    "    F(*composition)(F, F),",
    "    F(*id)()>",
    "struct lazy_segtree {",
    "public:",
    "    lazy_segtree() : lazy_segtree(0) {}",
    "    lazy_segtree(int32_t n) : lazy_segtree(std::vector<S>(n, e())) {}",
    "    lazy_segtree(const std::vector<S>& v) : _n(int32_t(v.size())) {",
    "        log = 64 - __builtin_clzll(_n);",
    "        size = 1 << log;",
    "        d = std::vector<S>(2 * size, e());",
    "        lz = std::vector<F>(size, id());",
    "        for (int32_t i = 0; i < _n; i++) d[size + i] = v[i];",
    "        for (int32_t i = size - 1; i >= 1; i--) {",
    "            update(i);",
    "        }",
    "    }",
    "",
    "    void set(int32_t p, S x) {",
    "        assert(0 <= p && p < _n);",
    "        p += size;",
    "        for (int32_t i = log; i >= 1; i--) push(p >> i);",
    "        d[p] = x;",
    "        for (int32_t i = 1; i <= log; i++) update(p >> i);",
    "    }",
    "",
    "    S get(int32_t p) {",
    "        assert(0 <= p && p < _n);",
    "        p += size;",
    "        for (int32_t i = log; i >= 1; i--) push(p >> i);",
    "        return d[p];",
    "    }",
    "",
    "    S prod(int32_t l, int32_t r) {",
    "        assert(0 <= l && l <= r && r <= _n);",
    "        if (l == r) return e();",
    "",
    "        l += size;",
    "        r += size;",
    "",
    "        for (int32_t i = log; i >= 1; i--) {",
    "            if (((l >> i) << i) != l) push(l >> i);",
    "            if (((r >> i) << i) != r) push(r >> i);",
    "        }",
    "",
    "        S sml = e(), smr = e();",
    "        while (l < r) {",
    "            if (l & 1) sml = op(sml, d[l++]);",
    "            if (r & 1) smr = op(d[--r], smr);",
    "            l >>= 1;",
    "            r >>= 1;",
    "        }",
    "",
    "        return op(sml, smr);",
    "    }",
    "",
    "    S all_prod() { return d[1]; }",
    "",
    "    void apply(int32_t p, F f) {",
    "        assert(0 <= p && p < _n);",
    "        p += size;",
    "        for (int32_t i = log; i >= 1; i--) push(p >> i);",
    "        d[p] = mapping(f, d[p]);",
    "        for (int32_t i = 1; i <= log; i++) update(p >> i);",
    "    }",
    "    void apply(int32_t l, int32_t r, F f) {",
    "        assert(0 <= l && l <= r && r <= _n);",
    "        if (l == r) return;",
    "",
    "        l += size;",
    "        r += size;",
    "",
    "        for (int32_t i = log; i >= 1; i--) {",
    "            if (((l >> i) << i) != l) push(l >> i);",
    "            if (((r >> i) << i) != r) push((r - 1) >> i);",
    "        }",
    "",
    "        {",
    "            int32_t l2 = l, r2 = r;",
    "            while (l < r) {",
    "                if (l & 1) all_apply(l++, f);",
    "                if (r & 1) all_apply(--r, f);",
    "                l >>= 1;",
    "                r >>= 1;",
    "            }",
    "            l = l2;",
    "            r = r2;",
    "        }",
    "",
    "        for (int32_t i = 1; i <= log; i++) {",
    "            if (((l >> i) << i) != l) update(l >> i);",
    "            if (((r >> i) << i) != r) update((r - 1) >> i);",
    "        }",
    "    }",
    "",
    "    template <bool (*g)(S)> int32_t max_right(int32_t l) {",
    "        return max_right(l, [](S x) { return g(x); });",
    "    }",
    "    template <class G> int32_t max_right(int32_t l, G g) {",
    "        assert(0 <= l && l <= _n);",
    "        assert(g(e()));",
    "        if (l == _n) return _n;",
    "        l += size;",
    "        for (int32_t i = log; i >= 1; i--) push(l >> i);",
    "        S sm = e();",
    "        do {",
    "            while (l % 2 == 0) l >>= 1;",
    "            if (!g(op(sm, d[l]))) {",
    "                while (l < size) {",
    "                    push(l);",
    "                    l = (2 * l);",
    "                    if (g(op(sm, d[l]))) {",
    "                        sm = op(sm, d[l]);",
    "                        l++;",
    "                    }",
    "                }",
    "                return l - size;",
    "            }",
    "            sm = op(sm, d[l]);",
    "            l++;",
    "        } while ((l & -l) != l);",
    "        return _n;",
    "    }",
    "",
    "    template <bool (*g)(S)> int32_t min_left(int32_t r) {",
    "        return min_left(r, [](S x) { return g(x); });",
    "    }",
    "    template <class G> int32_t min_left(int32_t r, G g) {",
    "        assert(0 <= r && r <= _n);",
    "        assert(g(e()));",
    "        if (r == 0) return 0;",
    "        r += size;",
    "        for (int32_t i = log; i >= 1; i--) push((r - 1) >> i);",
    "        S sm = e();",
    "        do {",
    "            r--;",
    "            while (r > 1 && (r % 2)) r >>= 1;",
    "            if (!g(op(d[r], sm))) {",
    "                while (r < size) {",
    "                    push(r);",
    "                    r = (2 * r + 1);",
    "                    if (g(op(d[r], sm))) {",
    "                        sm = op(d[r], sm);",
    "                        r--;",
    "                    }",
    "                }",
    "                return r + 1 - size;",
    "            }",
    "            sm = op(d[r], sm);",
    "        } while ((r & -r) != r);",
    "        return 0;",
    "    }",
    "",
    "private:",
    "    int32_t _n, size, log;",
    "    std::vector<S> d;",
    "    std::vector<F> lz;",
    "",
    "    void update(int32_t k) { d[k] = op(d[2 * k], d[2 * k + 1]); }",
    "    void all_apply(int32_t k, F f) {",
    "        d[k] = mapping(f, d[k]);",
    "        if (k < size) lz[k] = composition(f, lz[k]);",
    "    }",
    "    void push(int32_t k) {",
    "        all_apply(2 * k, lz[k]);",
    "        all_apply(2 * k + 1, lz[k]);",
    "        lz[k] = id();",
    "    }",
    "};",
    ""
  ],
  "description": "lazy segtree"
},
"stress.bat": {
  "prefix": "stress.bat",
  "body": [
    "@echo off",
    "",
    "if [%1]==[] (set /A numLoop = 100) else (set /A numLoop = %1)",
    "if [%2]==[] (set /A doComp = 1) else (set /A doComp = %2)",
    "",
    "if %doComp% equ 1 (",
    "    echo Compiling sol, gen, brute...",
    "",
    "    g++ -std=c++23 gen.cpp -o gen",
    "    g++ -std=c++23 sol.cpp -o sol",
    "    g++ -std=c++23 brute.cpp -o brute",
    "",
    "    echo Done compiling.",
    ")",
    "",
    "set \"diff_found=\"",
    "",
    "for /l %%x in (1, 1, %numLoop%) do (",
    "    echo %%x",
    "    gen > input.in",
    "    sol < input.in > output.out ",
    "    brute < input.in > output2.out",
    "",
    "    rem add \\f after \"fc\" to ignore trailing whitespaces and to convert",
    "    rem multiple whitespaces into one space",
    "    fc output.out output2.out > diagnostics",
    "    if errorlevel 1 (",
    "        set \"diff_found=y\"",
    "        goto :break",
    "    )",
    ")",
    "",
    ":break",
    "",
    "if defined diff_found (",
    "    echo A difference has been found.",
    "    echo Input: ",
    "    type input.in",
    "    echo.",
    "    echo.",
    "",
    "    echo Output:",
    "    type output.out",
    "    echo.",
    "",
    "    echo Expected:",
    "    type output2.out",
    "    echo.",
    ") else (",
    "    echo All tests passed :D",
    ")",
    "",
    "del input.in",
    "del output.out",
    "del output2.out"
  ],
  "description": "stress.bat"
},

}