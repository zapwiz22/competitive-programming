{
  "codechef temp": {
  "prefix": "chef",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "template <typename T>",
    "using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "",
    "#define int long long",
    "",
    "constexpr int INF = 1e18, MOD = 1000000007;",
    "",
    "struct Mint {",
    "    int x;",
    "    Mint(int x = 0) : x((x% MOD + MOD) % MOD) {",
    "    }",
    "    explicit operator int() const {",
    "        return x;",
    "    }",
    "    bool operator==(const Mint& rhs) const {",
    "        return x == rhs.x;",
    "    }",
    "    bool operator!=(const Mint& rhs) const {",
    "        return !(rhs == *this);",
    "    }",
    "    friend Mint operator+(const Mint& l, const Mint& r) {",
    "        return l.x + r.x;",
    "    }",
    "    Mint& operator+=(const Mint& o) {",
    "        return *this = *this + o;",
    "    }",
    "    friend Mint operator-(const Mint& l, const Mint& r) {",
    "        return l.x - r.x;",
    "    }",
    "    Mint operator-() const {",
    "        return -x;",
    "    }",
    "    Mint& operator-=(const Mint& o) {",
    "        return *this = *this - o;",
    "    }",
    "    friend Mint operator*(const Mint& l, const Mint& r) {",
    "        return (int)l.x * r.x;",
    "    }",
    "    Mint& operator*=(const Mint& o) {",
    "        return *this = *this * o;",
    "    }",
    "    Mint pow(int b) const {",
    "        Mint ans = 1;",
    "        Mint a = *this;",
    "        while (b > 0) {",
    "            if (b & 1)",
    "                ans *= a;",
    "            a = a * a;",
    "            b >>= 1;",
    "        }",
    "        return ans;",
    "    }",
    "    friend Mint operator/(const Mint& l, const Mint& r) {",
    "        return l * r.pow(MOD - 2);",
    "    }",
    "    Mint& operator/=(const Mint& o) {",
    "        return *this = *this / o;",
    "    }",
    "    friend ostream& operator<<(ostream& os, const Mint& o) {",
    "        return os << o.x;",
    "    }",
    "};",
    "",
    "constexpr int MAX_N = 1e6 + 14;",
    "Mint fac[MAX_N] = {1}, rfac[MAX_N] = {1};",
    "",
    "void prep() {",
    "    for (int i = 1; i < MAX_N; ++i)",
    "        fac[i] = fac[i - 1] * i;",
    "    rfac[MAX_N - 1] = 1 / fac[MAX_N - 1];",
    "    for (int i = MAX_N - 2; i >= 0; --i)",
    "        rfac[i] = (i + 1) * rfac[i + 1];",
    "}",
    "",
    "Mint c(int n, int r) {",
    "    return n < r || r < 0 ? 0 : fac[n] * rfac[r] * rfac[n - r];",
    "}",
    "",
    "/* Disjoint Set */",
    "struct DSU {",
    "private:",
    "    vector<int> par, sizes;",
    "",
    "public:",
    "    DSU(int n) : par(n), sizes(n, 1) { iota(par.begin(), par.end(), 0); }",
    "    int find(int x) { return (par[x] == x ? x : par[x] = find(par[x])); }",
    "    bool unite(int x, int y) {",
    "        int x_root = find(x), y_root = find(y);",
    "        if (x_root == y_root)",
    "            return false;",
    "        if (sizes[x_root] < sizes[y_root])",
    "            swap(x_root, y_root);",
    "        sizes[x_root] += sizes[y_root];",
    "        par[y_root] = x_root;",
    "        return true;",
    "    }",
    "    int tree_len(int x) { return sizes[find(x)]; }",
    "};",
    "",
    "/* Fenwick Tree */",
    "struct FenwickTree {",
    "    vector<int> bit;",
    "    FenwickTree(int size) { bit.resize(size + 2, 0); }",
    "    void update(int i, int delta) {",
    "        for (; i < (int)bit.size(); i += (i & (-i))) {",
    "            bit[i] += delta;",
    "        }",
    "    }",
    "    int get(int i) {",
    "        int sum = 0;",
    "        for (; i > 0; i -= (i & (-i))) {",
    "            sum += bit[i];",
    "        }",
    "        return sum;",
    "    }",
    "};",
    "",
    "/* Segment Tree */",
    "struct SegmentTree {",
    "    vector<int> tree;",
    "    int n;",
    "    SegmentTree(int n) {",
    "        tree.assign(2 * n, 0);",
    "        this->n = n;",
    "    }",
    "    void build() {",
    "        for (int i = n - 1; i > 0; i--) tree[i] = tree[i << 1] + tree[i << 1 | 1];",
    "    }",
    "    void modify(int p, int val) {",
    "        for (tree[p += n] = val; p > 1; p >>= 1) tree[p >> 1] = tree[p] + tree[p ^ 1];",
    "    }",
    "    int query(int l, int r) {",
    "        int res = 0;",
    "        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
    "            if (l & 1) res += tree[l++];",
    "            if (r & 1) res += tree[--r];",
    "        }",
    "        return res;",
    "    }",
    "};",
    "",
    "template <class T, class U>",
    "// source: https://github.com/sharmaharisam/Generic_all_purpose_segtree/blob/main/Segtree.cpp",
    "struct LSegTree {",
    "    vector<T> st;",
    "    vector<U> lazy;",
    "    int n;",
    "    T identity_element;",
    "    U identity_update;",
    "    /*",
    "    identity_element: element i such that combine(i,x)=x for any x",
    "    identity_update: update u such that apply(u,x)=x for any x",
    "    sum: identity_element=0;identity_update=<some number that cannot occur as an element in array after updating too>",
    "    max: identity_element=LLONG_MIN;identity_update=0;",
    "    min: identity_element=LLONG_MAX;identity_update=0;",
    "    */",
    "    LSegTree(int n, T identity_element, U identity_update) {",
    "        this->n = n;",
    "        this->identity_element = identity_element;",
    "        this->identity_update = identity_update;",
    "        st.assign(4 * n, identity_element);",
    "        lazy.assign(4 * n, identity_update);",
    "    }",
    "",
    "    T combine(T l, T r) {",
    "        // combine 2 nodes",
    "        T ans = max(l, r);",
    "        return ans;",
    "    }",
    "",
    "    void buildUtil(int v, int tl, int tr, vector<T>& a) {",
    "        if (tl == tr) {",
    "            st[v] = a[tl];",
    "            return;",
    "        }",
    "        int tm = (tl + tr) >> 1;",
    "        buildUtil(2 * v + 1, tl, tm, a);",
    "        buildUtil(2 * v + 2, tm + 1, tr, a);",
    "        st[v] = combine(st[2 * v + 1], st[2 * v + 2]);",
    "    }",
    "",
    "    T apply(T curr, U upd, int tl, int tr) {",
    "        // transform current answer curr to new answer upd for a node",
    "        T ans = max(curr, upd);",
    "        return ans;",
    "    }",
    "",
    "    U combineUpdate(U old_upd, U new_upd, int tl, int tr) {",
    "        // update lazy node with old and new values combined..",
    "        U ans = old_upd;",
    "        ans = max(ans, new_upd);",
    "        return ans;",
    "    }",
    "",
    "    void push_down(int v, int tl, int tr) {",
    "        if (lazy[v] == identity_update)",
    "            return;",
    "        st[v] = apply(st[v], lazy[v], tl, tr);",
    "        if (2 * v + 2 < 4 * n) {",
    "            int tm = (tl + tr) >> 1;",
    "            lazy[2 * v + 1] = combineUpdate(lazy[2 * v + 1], lazy[v], tl, tm);",
    "            lazy[2 * v + 2] = combineUpdate(lazy[2 * v + 2], lazy[v], tm + 1, tr);",
    "        }",
    "        lazy[v] = identity_update;",
    "    }",
    "",
    "    T queryUtil(int v, int tl, int tr, int l, int r) {",
    "        push_down(v, tl, tr);",
    "        if (l > r)",
    "            return identity_element;",
    "        if (tr < l or tl > r) {",
    "            return identity_element;",
    "        }",
    "        if (l <= tl and r >= tr) {",
    "            return st[v];",
    "        }",
    "        int tm = (tl + tr) >> 1;",
    "        return combine(queryUtil(2 * v + 1, tl, tm, l, r), queryUtil(2 * v + 2, tm + 1, tr, l, r));",
    "    }",
    "",
    "    void updateUtil(int v, int tl, int tr, int l, int r, U upd) {",
    "        push_down(v, tl, tr);",
    "        if (tr < l or tl > r)",
    "            return;",
    "        if (tl >= l and tr <= r) {",
    "            lazy[v] = combineUpdate(lazy[v], upd, tl, tr);",
    "            push_down(v, tl, tr);",
    "        } else {",
    "            int tm = (tl + tr) >> 1;",
    "            updateUtil(2 * v + 1, tl, tm, l, r, upd);",
    "            updateUtil(2 * v + 2, tm + 1, tr, l, r, upd);",
    "            st[v] = combine(st[2 * v + 1], st[2 * v + 2]);",
    "        }",
    "    }",
    "",
    "    void build(vector<T> a) {",
    "        assert((int)a.size() == n);",
    "        buildUtil(0, 0, n - 1, a);",
    "    }",
    "    T query(int l, int r) {",
    "        return queryUtil(0, 0, n - 1, l, r);",
    "    }",
    "    void update(int l, int r, U upd) {",
    "        updateUtil(0, 0, n - 1, l, r, upd);",
    "    }",
    "};",
    "",
    "/* Sparse Table */",
    "",
    "/*",
    "    find the queries in O(1)",
    "    precalculates everything in log terms O(nlogn)",
    "    and then gives the result by using the precalculated stuff",
    "*/",
    "",
    "struct SparseTable {",
    "    vector<int> a;",
    "    vector<vector<int>> sp;",
    "    int LOG, mxeN;",
    "    SparseTable(int mxeSize) {",
    "        a.resize(mxeSize, 0);",
    "        mxeN = mxeSize;",
    "        LOG = log2(mxeSize) + 1;",
    "        sp.assign(mxeN, vector<int>(LOG, 0));",
    "    }",
    "    void modify(int idx, int val) {",
    "        a[idx] = val;",
    "        sp[idx][0] = val;",
    "    }",
    "    void build() {",
    "        for (int j = 1; j < LOG; j++) {",
    "            for (int i = 0; i + (1 << j) - 1 < mxeN; i++) {",
    "                sp[i][j] = gcd(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);",
    "            }",
    "        }",
    "    }",
    "    int query(int l, int r) {",
    "        int len = r - l + 1;",
    "        int k = 31 - __builtin_clz(len);",
    "        return gcd(sp[l][k], sp[r - (1 << k) + 1][k]);",
    "    }",
    "};",
    "",
    "/* Z-Algorithm */",
    "vector<int> z_func(string s) {",
    "    int n = s.size();",
    "    vector<int> z(n);",
    "    int x = 0, y = 0;",
    "    for (int i = 0; i < n; i++) {",
    "        z[i] = max(0LL, min(z[i - x], y - i + 1));",
    "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
    "            x = i, y = i + z[i], z[i]++;",
    "        }",
    "    }",
    "    return z;",
    "}",
    "",
    "/*********************** main ************************/",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(false);",
    "    cin.tie(0);",
    "",
    "    int tt = 1;",
    "    cin >> tt;",
    "    while (tt--) {",
    "        $0",
    "    }",
    "",
    "    return 0;",
    "}"
  ],
  "description": "codechef temp"
},
"jayant": {
  "prefix": "jayant",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "template <typename T>",
    "using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
    "",
    "#define int long long",
    "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
    "const int INF = 1e18, MOD = 1000000007; // 998244353;",
    "",
    "void Solve() {",
    "    $0",
    "}",
    "",
    "#undef int",
    "",
    "int main() {",
    "#ifdef ZAP",
    "    freopen(\"int\", \"r\", stdin), freopen(\"out1\", \"w\", stdout), freopen(\"err\", \"w\", stderr);",
    "#endif",
    "    auto begin = std::chrono::high_resolution_clock::now();",
    "    ios_base::sync_with_stdio(false), cin.tie(nullptr);",
    "    int T = 1;",
    "    cin >> T;",
    "    for (int i = 1; i <= T; i++) {",
    "        cerr << \"Case #\" << i << \": \" << endl;",
    "        Solve();",
    "    }",
    "    auto end = std::chrono::high_resolution_clock::now();",
    "    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);",
    "    cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\";",
    "    return 0;",
    "}"
  ],
  "description": "jayant"
},
"tnayaj": {
  "prefix": "tnayaj",
  "body": [
    "/*",
    " *  author: tnayaj",
    " *  created: $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
    "*/",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define int long long ",
    "constexpr int INF = 1e18, MOD = 1e9 + 7;",
    "",
    "int32_t main() {",
    "    ios_base::sync_with_stdio(false);",
    "    cin.tie(0);",
    "",
    "    int tt = 1;",
    "    cin >> tt; $1",
    "    while (tt--) {",
    "        $0",
    "    }",
    "",
    "    return 0;",
    "}"
  ],
  "description": "tnayaj"
},
"jk": {
  "prefix": "jk",
  "body": [
    "/*",
    " *  author: zapwiz22",
    " *  created: $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
    "*/",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "#define int long long",
    "mt19937_64 RNG(chrono::steady_clock::now().time_since_epoch().count());",
    "const int INF = 1e18, MOD = 1000000007; // 998244353;",
    "",
    "void Solve() {",
    "    $0    ",
    "}",
    "",
    "int32_t main() {",
    "    auto begin = std::chrono::high_resolution_clock::now();",
    "    ios_base::sync_with_stdio(false), cin.tie(nullptr);",
    "    int tt = 1;",
    "    $1cin >> tt;",
    "    for (int i = 1; i <= tt; i++) {",
    "        cerr << \"Case #\" << i << \": \" << endl;",
    "        Solve();",
    "    }",
    "    auto end = std::chrono::high_resolution_clock::now();",
    "    auto elapsed = std::chrono::duration_cast<std::chrono::nanoseconds>(end - begin);",
    "    cerr << \"Time measured: \" << elapsed.count() * 1e-9 << \" seconds.\\n\";",
    "    return 0;",
    "}"
  ],
  "description": "jk"
},
"oset": {
  "prefix": "oset",
  "body": [
    "#include <ext/pb_ds/assoc_container.hpp>",
    "#include <ext/pb_ds/tree_policy.hpp>",
    "using namespace __gnu_pbds;",
    "template <typename T>",
    "using oset = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>; "
  ],
  "description": "oset"
},
"modint": {
  "prefix": "modint",
  "body": [
    "constexpr int MAX_N = 1e6 + 14;",
    "",
    "struct Mint {",
    "    int x;",
    "    Mint(int x = 0) : x((x % MOD + MOD) % MOD) {",
    "    }",
    "    explicit operator int() const {",
    "        return x;",
    "    }",
    "    bool operator==(const Mint& rhs) const {",
    "        return x == rhs.x;",
    "    }",
    "    bool operator!=(const Mint& rhs) const {",
    "        return !(rhs == *this);",
    "    }",
    "    friend Mint operator+(const Mint& l, const Mint& r) {",
    "        return l.x + r.x;",
    "    }",
    "    Mint& operator+=(const Mint& o) {",
    "        return *this = *this + o;",
    "    }",
    "    friend Mint operator-(const Mint& l, const Mint& r) {",
    "        return l.x - r.x;",
    "    }",
    "    Mint operator-() const {",
    "        return -x;",
    "    }",
    "    Mint& operator-=(const Mint& o) {",
    "        return *this = *this - o;",
    "    }",
    "    friend Mint operator*(const Mint& l, const Mint& r) {",
    "        return (int)l.x * r.x;",
    "    }",
    "    Mint& operator*=(const Mint& o) {",
    "        return *this = *this * o;",
    "    }",
    "    Mint pow(int b) const {",
    "        Mint ans = 1;",
    "        Mint a = *this;",
    "        while (b > 0) {",
    "            if (b & 1)",
    "                ans *= a;",
    "            a = a * a;",
    "            b >>= 1;",
    "        }",
    "        return ans;",
    "    }",
    "    friend Mint operator/(const Mint& l, const Mint& r) {",
    "        return l * r.pow(MOD - 2);",
    "    }",
    "    Mint& operator/=(const Mint& o) {",
    "        return *this = *this / o;",
    "    }",
    "    friend ostream& operator<<(ostream& os, const Mint& o) {",
    "        return os << o.x;",
    "    }",
    "};",
    "",
    "Mint fac[MAX_N] = {1}, rfac[MAX_N] = {1};",
    "",
    "void prep() {",
    "    for (int i = 1; i < MAX_N; ++i)",
    "        fac[i] = fac[i - 1] * i;",
    "    rfac[MAX_N - 1] = 1 / fac[MAX_N - 1];",
    "    for (int i = MAX_N - 2; i >= 0; --i)",
    "        rfac[i] = (i + 1) * rfac[i + 1];",
    "}",
    "",
    "Mint c(int n, int r) {",
    "    return n < r || r < 0 ? 0 : fac[n] * rfac[r] * rfac[n - r];",
    "}"
  ],
  "description": "modint"
},
"z-algorithm": {
  "prefix": "zalgorithm",
  "body": [
    "/* Z-Algorithm */",
    "vector<int> z_func(string s) {",
    "    int n = s.size();",
    "    vector<int> z(n);",
    "    int x = 0, y = 0;",
    "    for (int i = 0; i < n; i++) {",
    "        z[i] = max(0, min(z[i - x], y - i + 1));",
    "        while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {",
    "            x = i, y = i + z[i], z[i]++;",
    "        }",
    "    }",
    "    return z;",
    "}",
    ""
  ],
  "description": "z-algorithm"
},
"disjoint-set": {
  "prefix": "disjointset",
  "body": [
    "struct DSU {",
    "  private:",
    "    vector<int> par, sizes;",
    "",
    "  public:",
    "    DSU(int n) : par(n), sizes(n, 1) { iota(par.begin(), par.end(), 0); }",
    "    int find(int x) { return (par[x] == x ? x : par[x] = find(par[x])); }",
    "    bool unite(int x, int y) {",
    "        int x_root = find(x), y_root = find(y);",
    "        if (x_root == y_root)",
    "            return false;",
    "        if (sizes[x_root] < sizes[y_root])",
    "            swap(x_root, y_root);",
    "        sizes[x_root] += sizes[y_root];",
    "        par[y_root] = x_root;",
    "        return true;",
    "    }",
    "    int tree_len(int x) { return sizes[find(x)]; }",
    "};",
    ""
  ],
  "description": "disjoint-set"
},
"sparse table": {
  "prefix": "sparsetable",
  "body": [
    "/* Sparse Table */",
    "/*",
    "    find the queries in O(1)",
    "    precalculates everything in log terms O(nlogn)",
    "    and then gives the result by using the precalculated stuff",
    "*/",
    "struct SparseTable {",
    "    vector<int> a;",
    "    vector<vector<int>> sp;",
    "    int LOG, mxeN;",
    "    SparseTable(int mxeSize) {",
    "        a.resize(mxeSize, 0);",
    "        mxeN = mxeSize;",
    "        LOG = log2(mxeSize) + 1;",
    "        sp.assign(mxeN, vector<int>(LOG, 0));",
    "    }",
    "    void modify(int idx, int val) {",
    "        a[idx] = val;",
    "        sp[idx][0] = val;",
    "    }",
    "    void build() {",
    "        for (int j = 1; j < LOG; j++) {",
    "            for (int i = 0; i + (1 << j) - 1 < mxeN; i++) {",
    "                sp[i][j] = gcd(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);",
    "            }",
    "        }",
    "    }",
    "    int query(int l, int r) {",
    "        int len = r - l + 1;",
    "        int k = 31 - __builtin_clz(len);",
    "        return gcd(sp[l][k], sp[r - (1 << k) + 1][k]);",
    "    }",
    "};",
    ""
  ],
  "description": "sparse table"
},
"fenwick tree": {
  "prefix": "fenwick",
  "body": [
    "template <typename T>",
    "struct fenwick {",
    "    int n;",
    "    vector<T> bit;",
    "",
    "    fenwick(int n) : n(n), bit(n + 1, T()) {}",
    "",
    "    // give 0-based and operations are done 1-based ",
    "    void update(int i, T delta) {",
    "        for (++i; i <= n; i += i & -i) {",
    "            bit[i] = bit[i] + delta;",
    "        }",
    "    }",
    "    T query(int i) {",
    "        T res{};",
    "        for (++i; i > 0; i -= i & -i) {",
    "            res = res + bit[i];",
    "        }",
    "        return res;",
    "    }",
    "};",
    "",
    "struct node {",
    "    int a = 0; // don't forget the default value ",
    "",
    "    // define the required operations",
    "    inline node operator+(node& x) {",
    "        return node(a - x.a);",
    "    }",
    "    inline bool operator<(node& x) {",
    "        return a < x.a;",
    "    }",
    "};"
  ],
  "description": "fenwick tree"
},
"stress": {
  "prefix": "stress",
  "body": [
    "#!/bin/bash",
    "",
    "g++ sol.cpp -o sol",
    "g++ brute.cpp -o brute",
    "g++ gen.cpp -o gen",
    "",
    "for ((i = 1; i <= 1000; ++i)); do",
    "    echo $i",
    "    ./gen $i >int",
    "    ./sol <int >out1",
    "    ./brute <int >out2",
    "    diff -w out1 out2 || break",
    "done"
  ],
  "description": "stress"
},
"generation": {
  "prefix": "gen",
  "body": [
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "#define int long long ",
    "#define uid(a, b) uniform_int_distribution<int>(a, b)(rng)",
    "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
    "",
    "int32_t main() {",
    "    int tests = 1;",
    "    cout << tests << endl;",
    "",
    "    // generation ",
    "    $0",
    "",
    "    return 0;",
    "}",
    "",
    "/* how to generate a tree",
    "  print uid(1,i-1) and i",
    "*/",
    "",
    "/* how to randomly shuffle a vector",
    "   // Initialize random number generator",
    "    random_device rd;",
    "    mt19937 g(rd());",
    "",
    "    // Shuffle the vector",
    "    shuffle(v.begin(), v.end(), g);",
    "*/"
  ],
  "description": "generation"
},
"debug.h": {
  "prefix": "debug",
  "body": [
    "#ifndef DEBUG_H",
    "#define DEBUG_H",
    "",
    "#include <bits/stdc++.h>",
    "using namespace std;",
    "",
    "// Forward declarations for all _print functions",
    "void _print(int x);",
    "void _print(long x);",
    "void _print(long long x);",
    "void _print(unsigned x);",
    "void _print(unsigned long x);",
    "void _print(unsigned long long x);",
    "void _print(float x);",
    "void _print(double x);",
    "void _print(long double x);",
    "void _print(char x);",
    "void _print(const char* x);",
    "void _print(const string& x);",
    "void _print(bool x);",
    "",
    "template<typename T1, typename T2>",
    "void _print(const pair<T1, T2>& p);",
    "",
    "template<typename T>",
    "void _print(const vector<T>& v);",
    "",
    "template<typename T>",
    "void _print(const set<T>& s);",
    "",
    "template<typename T>",
    "void _print(const unordered_set<T>& s);",
    "",
    "template<typename T>",
    "void _print(const multiset<T>& s);",
    "",
    "template<typename K, typename V>",
    "void _print(const map<K, V>& m);",
    "",
    "template<typename K, typename V>",
    "void _print(const unordered_map<K, V>& m);",
    "",
    "template<typename T, size_t N>",
    "void _print(const array<T, N>& arr);",
    "",
    "template<typename T>",
    "void _print(const deque<T>& dq);",
    "",
    "template<typename T>",
    "void _print(stack<T> st);",
    "",
    "template<typename T>",
    "void _print(queue<T> q);",
    "",
    "template<typename T>",
    "void _print(priority_queue<T> pq);",
    "",
    "template<typename T>",
    "void _print(priority_queue<T, vector<T>, greater<T>> pq);",
    "",
    "template<typename T>",
    "void _print(const list<T>& lst);",
    "",
    "template<typename T>",
    "void _print(const forward_list<T>& flst);",
    "",
    "template<size_t N>",
    "void _print(const bitset<N>& bs);",
    "",
    "template<typename... Args>",
    "void _print(const tuple<Args...>& t);",
    "",
    "template<typename T>",
    "void _print(const complex<T>& c);",
    "",
    "// Core type printers implementation",
    "void _print(int x) { cerr << x; }",
    "void _print(long x) { cerr << x; }",
    "void _print(long long x) { cerr << x; }",
    "void _print(unsigned x) { cerr << x; }",
    "void _print(unsigned long x) { cerr << x; }",
    "void _print(unsigned long long x) { cerr << x; }",
    "void _print(float x) { cerr << x; }",
    "void _print(double x) { cerr << x; }",
    "void _print(long double x) { cerr << x; }",
    "void _print(char x) { cerr << '\\'' << x << '\\''; }",
    "void _print(const char* x) { cerr << '\\\"' << x << '\\\"'; }",
    "void _print(const string& x) { cerr << '\\\"' << x << '\\\"'; }",
    "void _print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
    "",
    "// Pair",
    "template<typename T1, typename T2>",
    "void _print(const pair<T1, T2>& p) {",
    "    cerr << '{';",
    "    _print(p.first);",
    "    cerr << ',';",
    "    _print(p.second);",
    "    cerr << '}';",
    "}",
    "",
    "// Vector",
    "template<typename T>",
    "void _print(const vector<T>& v) {",
    "    cerr << '[';",
    "    for (size_t i = 0; i < v.size(); i++) {",
    "        if (i > 0) cerr << ',';",
    "        _print(v[i]);",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Set",
    "template<typename T>",
    "void _print(const set<T>& s) {",
    "    cerr << '{';",
    "    for (auto it = s.begin(); it != s.end();) {",
    "        _print(*it);",
    "        if (++it != s.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Unordered Set",
    "template<typename T>",
    "void _print(const unordered_set<T>& s) {",
    "    cerr << '{';",
    "    for (auto it = s.begin(); it != s.end();) {",
    "        _print(*it);",
    "        if (++it != s.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Multiset",
    "template<typename T>",
    "void _print(const multiset<T>& s) {",
    "    cerr << '{';",
    "    for (auto it = s.begin(); it != s.end();) {",
    "        _print(*it);",
    "        if (++it != s.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Map",
    "template<typename K, typename V>",
    "void _print(const map<K, V>& m) {",
    "    cerr << '{';",
    "    for (auto it = m.begin(); it != m.end();) {",
    "        _print(it->first);",
    "        cerr << ':';",
    "        _print(it->second);",
    "        if (++it != m.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Unordered Map",
    "template<typename K, typename V>",
    "void _print(const unordered_map<K, V>& m) {",
    "    cerr << '{';",
    "    for (auto it = m.begin(); it != m.end();) {",
    "        _print(it->first);",
    "        cerr << ':';",
    "        _print(it->second);",
    "        if (++it != m.end()) cerr << ',';",
    "    }",
    "    cerr << '}';",
    "}",
    "",
    "// Array",
    "template<typename T, size_t N>",
    "void _print(const array<T, N>& arr) {",
    "    cerr << '[';",
    "    for (size_t i = 0; i < N; i++) {",
    "        if (i > 0) cerr << ',';",
    "        _print(arr[i]);",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Deque",
    "template<typename T>",
    "void _print(const deque<T>& dq) {",
    "    cerr << '[';",
    "    for (size_t i = 0; i < dq.size(); i++) {",
    "        if (i > 0) cerr << ',';",
    "        _print(dq[i]);",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Stack",
    "template<typename T>",
    "void _print(stack<T> st) {",
    "    vector<T> temp;",
    "    while (!st.empty()) {",
    "        temp.push_back(st.top());",
    "        st.pop();",
    "    }",
    "    reverse(temp.begin(), temp.end());",
    "    cerr << \"stack:\";",
    "    _print(temp);",
    "}",
    "",
    "// Queue",
    "template<typename T>",
    "void _print(queue<T> q) {",
    "    vector<T> temp;",
    "    while (!q.empty()) {",
    "        temp.push_back(q.front());",
    "        q.pop();",
    "    }",
    "    cerr << \"queue:\";",
    "    _print(temp);",
    "}",
    "",
    "// Priority Queue (max heap)",
    "template<typename T>",
    "void _print(priority_queue<T> pq) {",
    "    vector<T> temp;",
    "    while (!pq.empty()) {",
    "        temp.push_back(pq.top());",
    "        pq.pop();",
    "    }",
    "    cerr << \"max_heap:\";",
    "    _print(temp);",
    "}",
    "",
    "// Priority Queue (min heap)",
    "template<typename T>",
    "void _print(priority_queue<T, vector<T>, greater<T>> pq) {",
    "    vector<T> temp;",
    "    while (!pq.empty()) {",
    "        temp.push_back(pq.top());",
    "        pq.pop();",
    "    }",
    "    cerr << \"min_heap:\";",
    "    _print(temp);",
    "}",
    "",
    "// List",
    "template<typename T>",
    "void _print(const list<T>& lst) {",
    "    cerr << '[';",
    "    for (auto it = lst.begin(); it != lst.end();) {",
    "        _print(*it);",
    "        if (++it != lst.end()) cerr << ',';",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Forward List",
    "template<typename T>",
    "void _print(const forward_list<T>& flst) {",
    "    cerr << '[';",
    "    for (auto it = flst.begin(); it != flst.end();) {",
    "        _print(*it);",
    "        if (++it != flst.end()) cerr << ',';",
    "    }",
    "    cerr << ']';",
    "}",
    "",
    "// Bitset",
    "template<size_t N>",
    "void _print(const bitset<N>& bs) {",
    "    cerr << \"bitset:\\\"\";",
    "    for (size_t i = 0; i < N; i++) {",
    "        cerr << (bs.test(i) ? '1' : '0');",
    "    }",
    "    cerr << \"\\\"\";",
    "}",
    "",
    "// Tuple",
    "template<typename Tuple, size_t... Is>",
    "void _print_tuple(const Tuple& t, index_sequence<Is...>) {",
    "    cerr << '(';",
    "    (..., (cerr << (Is == 0 ? \"\" : \",\"), _print(get<Is>(t))));",
    "    cerr << ')';",
    "}",
    "",
    "template<typename... Args>",
    "void _print(const tuple<Args...>& t) {",
    "    _print_tuple(t, index_sequence_for<Args...>{});",
    "}",
    "",
    "// Complex",
    "template<typename T>",
    "void _print(const complex<T>& c) {",
    "    cerr << c.real();",
    "    if (c.imag() >= 0) cerr << '+';",
    "    cerr << c.imag() << 'i';",
    "}",
    "",
    "// Main debug function",
    "#define debug(...) debug_print(#__VA_ARGS__, __VA_ARGS__)",
    "",
    "template<typename... Args>",
    "void debug_print(const char* names, Args&&... args) {",
    "    cerr << \"\\033[1;36m\";",
    "    stringstream ss(names);",
    "    string name;",
    "    vector<string> vnames;",
    "    ",
    "    // Parse variable names",
    "    while (getline(ss, name, ',')) {",
    "        name.erase(0, name.find_first_not_of(\" \\t\\n\\r\\f\\v\"));",
    "        name.erase(name.find_last_not_of(\" \\t\\n\\r\\f\\v\") + 1);",
    "        vnames.push_back(name);",
    "    }",
    "    ",
    "    // Print each variable with its name",
    "    int i = 0;",
    "    ((cerr << (i++ ? \" | \" : \"\") << vnames[i-1] << \" = \", _print(args)), ...);",
    "    cerr << \"\\033[0m\" << endl;",
    "}",
    "",
    "#endif // DEBUG_H"
  ],
  "description": "debug.h"
},

}