{
  "minimal template": {
    "prefix": "jayant",
    "body": [
      "/*",
      " * author: zapwiz22",
      " * created on ${CURRENT_DATE}-${CURRENT_MONTH}-${CURRENT_YEAR} at ${CURRENT_HOUR}:${CURRENT_MINUTE}:${CURRENT_SECOND}",
      " */",
      "",
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "using namespace __gnu_pbds;",
      "",
      "typedef long long ll;",
      "template <typename T>",
      "using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "",
      "#ifdef LOCAL",
      "#include \"debug.h\"",
      "#else",
      "#define debug(...)",
      "#endif",
      "",
      "#define mod 1000000007",
      "#define mod1 998244353",
      "#define inf 1e15",
      "#define linf 2e18",
      "#define nl '\\n'",
      "",
      "const ll N = 1e3 + 1;",
      "",
      "void solve() {",
      "    $0",
      "}",
      "",
      "int main() {",
      "    ios_base::sync_with_stdio(false), cin.tie(nullptr);",
      "    ll TESTS = 1;",
      "    cin >> TESTS;",
      "    while (TESTS--) {",
      "        solve();",
      "    }",
      "    return 0;",
      "}"
    ],
    "description": "minimal template"
  },
  "basic segment tree": {
    "prefix": "basic segment tree",
    "body": [
      "struct SegmentTree {",
      "    vector<ll> tree;",
      "    ll n;",
      "    SegmentTree(ll n) {",
      "        tree.resize(2 * n, 0);",
      "        this->n = n;",
      "    }",
      "    void build() {",
      "        for (int i = n - 1; i > 0; i--)",
      "            // tree[i] = tree[i << 1] + tree[i << 1 | 1];",
      "            tree[i] = gcd(tree[i << 1], tree[i << 1 | 1]);",
      "    }",
      "    void modify(ll p, ll val) {",
      "        for (tree[p += n] = val; p > 1; p >>= 1)",
      "            tree[p >> 1] = gcd(tree[p], tree[p ^ 1]);",
      "        // tree[p >> 1] = tree[p] + tree[p ^ 1];",
      "    }",
      "    ll query(ll l, ll r) {",
      "        ll res = 0;",
      "        for (l += n, r += n; l < r; l >>= 1, r >>= 1) {",
      "            if (l & 1)",
      "                // res += tree[l++];",
      "                res = gcd(res, tree[l++]);",
      "            if (r & 1)",
      "                // res += tree[--r];",
      "                res = gcd(res, tree[--r]);",
      "        }",
      "        return res;",
      "    }",
      "};"
    ],
    "description": "basic segment tree"
  },
  "fenwick tree": {
    "prefix": "fenwick tree",
    "body": [
      "struct FenwickTree {",
      "    vector<ll> bit;",
      "    FenwickTree(ll size) { bit.resize(size + 2, 0); }",
      "    void update(ll i, ll delta) {",
      "        for (; i < bit.size(); i += (i & (-i))) {",
      "            // bit[i] += delta;",
      "            bit[i] = (bit[i] + delta) % mod;",
      "        }",
      "    }",
      "    ll get(ll i) {",
      "        ll sum = 0;",
      "        for (; i > 0; i -= (i & (-i))) {",
      "            // sum += bit[i];",
      "            sum = (sum + bit[i]) % mod;",
      "        }",
      "        return sum;",
      "    }",
      "};"
    ],
    "description": "fenwick tree"
  },
  "sparse table": {
    "prefix": "sparse table",
    "body": [
      "struct SparseTable {",
      "    vector<ll> a;",
      "    vector<vector<ll>> sp;",
      "    ll LOG, mxeN;",
      "    SparseTable(ll mxeSize) {",
      "        a.resize(mxeSize, 0);",
      "        mxeN = mxeSize;",
      "        LOG = log2(mxeSize) + 1;",
      "        sp.assign(mxeN, vector<ll>(LOG, 0));",
      "    }",
      "    void modify(ll idx, ll val) {",
      "        a[idx] = val;",
      "        sp[idx][0] = val;",
      "    }",
      "    void build() {",
      "        for (int j = 1; j < LOG; j++) {",
      "            for (int i = 0; i + (1 << j) - 1 < mxeN; i++) {",
      "                sp[i][j] = gcd(sp[i][j - 1], sp[i + (1 << (j - 1))][j - 1]);",
      "            }",
      "        }",
      "    }",
      "    ll query(ll l, ll r) {",
      "        ll len = r - l + 1;",
      "        ll k = 31 - __builtin_clz(len);",
      "        return gcd(sp[l][k], sp[r - (1 << k) + 1][k]);",
      "    }",
      "};"
    ],
    "description": "sparse table"
  },
  "disjoint set": {
    "prefix": "disjoint set",
    "body": [
      "class DisjointSet {",
      "   private:",
      "    vector<ll> par, sizes;",
      "",
      "   public:",
      "    DisjointSet(ll n) : par(n), sizes(n, 1) { iota(par.begin(), par.end(), 0); }",
      "    ll find(ll x) { return (par[x] == x ? x : par[x] = find(par[x])); }",
      "    bool unite(ll x, ll y) {",
      "        ll x_root = find(x), y_root = find(y);",
      "        if (x_root == y_root)",
      "            return false;",
      "        if (sizes[x_root] < sizes[y_root])",
      "            swap(x_root, y_root);",
      "        sizes[x_root] += sizes[y_root];",
      "        par[y_root] = x_root;",
      "        return true;",
      "    }",
      "    ll tree_len(ll x) { return sizes[find(x)]; }",
      "};"
    ],
    "description": "disjoint set"
  },
  "binexpo": {
    "prefix": "binexpo",
    "body": [
      "ll binexpo(ll a, ll b, ll MOD = LLONG_MAX) {",
      "    ll res = 1;",
      "    while (b > 0) {",
      "        if (b & 1)",
      "            res = 1ll * res * a % MOD;",
      "        a = 1ll * a * a % MOD;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}"
    ],
    "description": "binexpo"
  },
  "fermat little theorem modular inverse": {
    "prefix": "fermat mod inverse",
    "body": [
      "/* Binary Exponentiation */",
      "ll binexpo(ll a, ll b, ll MOD = LLONG_MAX) {",
      "    ll res = 1;",
      "    while (b > 0) {",
      "        if (b & 1)",
      "            res = 1ll * res * a % MOD;",
      "        a = 1ll * a * a % MOD;",
      "        b >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "/* Fermat's Little Theorem - Modular Inverse */",
      "ll modinv(ll x, ll MOD) { return binexpo(x, MOD - 2, MOD); }"
    ],
    "description": "fermat little theorem modular inverse"
  },
  "modular operations": {
    "prefix": "mod ops",
    "body": [
      "/* Modular Operations */",
      "ll modadd(ll a, ll b, ll MOD) { return ((a % MOD) + (b % MOD)) % MOD; }",
      "ll modsub(ll a, ll b, ll MOD) { return ((a % MOD) - (b % MOD) + MOD) % MOD; }",
      "ll modmul(ll a, ll b, ll MOD) { return ((a % MOD) * (b % MOD)) % MOD; }"
    ],
    "description": "modular operations"
  }
}
